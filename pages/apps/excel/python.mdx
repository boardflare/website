---
title: Python for Excel
icon: python.png
---

import { Callout } from 'nextra/components'

# Python for Excel

<Callout type="warning" emoji="üß™">
  **EXPERIMENTAL**:  Breaking changes are probable.  [Feedback](/company/support) is appreciated!
</Callout>

## Overview

Runs Python code as a function so you can incorporate it into your formulas and LAMBDA functions.  For example, incorporating Python code in a LAMBDA function which is then named `MYFUNC` and called with `5, 3`:
    
```excel
=LAMBDA(x, y, BOARDFLARE.PY("pyout = data1 * data2", x, y))
=MYFUNC(5, 3)
```
This enables you to create extremely powerful custom functions without needing to build a custom Excel add-in.

<a href="https://appsource.microsoft.com/en-us/product/office/WA200007447?tab=Overview">
    <img 
        src="/images/MS_AppSource.png" 
        alt="AppSource"
        style={{ paddingTop: '10px', width: '150px' }}
    />
</a>

## Features

Some key differences compared to the native [Python in Excel](https://support.microsoft.com/en-us/office/get-started-with-python-in-excel-a33fbcbe-065b-41d3-82cf-23d05397f53d) are as follows:

üÜì Free add-in, no Office 365 license required.<br/>
üåê Works in Excel for web as well as desktop.<br/>
‚òÅÔ∏è Runtime has network access for API calls.<br/>
üì¶ Import custom packages (pure Python only).<br/>
üîí Runs locally, so no data is shared outside Excel.<br/>
‚úÖ Can be used inside formulas and LAMBDA functions.<br/>
‚û°Ô∏è Code can be centralized and loaded from a URL.<br/>
üöÄ Performance is only limited by your CPU.<br/>

## Runtime

[Pyodide](https://pyodide.org/en/stable/index.html) is the Python runtime, which is based on [WebAssembly](https://webassembly.org/) running in the browser used by Excel desktop and web to host add-ins.  This is currently running Python 3.12, but has limitations as discussed in the [Pyodide documentation](https://pyodide.org/en/stable/usage/wasm-constraints.html).

Pyodide includes a number of [built-in packages](https://pyodide.org/en/stable/usage/packages-in-pyodide.html). You can import any of these packages as well as those from the Python standard library. Any imports for external Python packages will be loaded from [PyPI](https://pypi.org/), but only if they are pure Python, which means there is a Python wheel that ends with `-py3-none-any.whl`, e.g. `beautifulsoup4-4.12.3-py3-none-any.whl`.  Packages tagged as [OS-independent](https://pypi.org/search/?q=&o=&c=Operating+System+%3A%3A+OS+Independent) on PyPI should work, but double-check the wheel.

Any output to `stdout` or `stderr` is displayed in the Console area of the add-in task pane. This is useful for debugging your code, and also for displaying intermediate results of long-running operations such as functions that are processing large input arrays. 

Global variables are used to pass data to your code, as discussed in more detail below.  Global variables are cleared after each function invocation, so no state is maintained between calls.

## Functions

Functions are accessed in the `BOARDFLARE` namespace (e.g. `=BOARDFLARE.PY(code, [data1])`).  See our [example workbook](https://1drv.ms/x/s!AmvHMvGKbZDOibEu75MVo8mvZqbAkg?e=XRMdBI) for usage.

### PY

The `PY` function executes Python code with optional repeating **scalar** arguments `data1, data2, ...` which are assigned to global variables and returns a **scalar** (e.g. 5 in a single cell).

```excel
=BOARDFLARE.PY(code, [data1])
```

| Argument | Type   | Optional | Description |
|----------|--------|----------|-------------|
| code     | string | No       | Python code, or URL to code, e.g. `https://foo.com/code.py`.  Python code must assign global variable `pyout` with a **scalar** of type `int, float, bool, or str`. |
| data1    | number, string, boolean | Yes       | Repeating argument that will set global **scalar** variables `data1, data2, ..` which you can then reference in your code to pass in data. |

A simple example is as follows:

```excel
=BOARDFLARE.PY("pyout = data1 * data2", 5, 3)
```
This sets global variables `data1 = 5 ; data2 = 3`, evaluates to `pyout = 15`, and returns `15` in a single cell.

Or loading from URL:

```excel
=BOARDFLARE.PY("https://foo.com/code.py", 5, 3)
```
where `mycode.py` contains the same code as above.  Note that the URL must be served over HTTPS.

You could assign serialized arrays (e.g. using `ARRAYTOTEXT`) to `data1, data2, ..` and return a serialized array which you deserialize in Excel, but a simpler approach is to use the `PY.ARR` function below which natively handles arrays.

### PY.ARR

The `PY.ARR` function is the same as `PY` except that it takes arrays for `data1, data2, ...` and outputs an array result to Excel.  Remember that **an array variable in Excel is always a 2D array, or matrix**, even if it represents a single row or column, or even a single cell.  Excel custom functions use the term **matrix** instead of array to help clarify this, and that is what we will do here also.

```excel
=BOARDFLARE.PY.ARR(code, [data1])
```

| Argument | Type   | Optional | Description |
|----------|--------|----------|-------------|
| code     | string | No       | Python code, or URL to code, e.g. `https://foo.com/code.py`.  Python code must assign global variable `pyout` with an **matrix** of elements of type `int, float, bool, or str`. |
| data1    | array | Yes       | Repeating argument that will set global **matrix** variables `data1, data2, ..`. Values can be a range `A2:A3`, array constant `{2,3}`, or a function that returns an array. | 

You could use `PY.ARR` for scalars, but since everything is handled as a matrix, it can be a bit cumbersome.  Let's implement the previous example using `PY.ARR`:
    
```excel
=BOARDFLARE.PY.ARR("pyout = [[data1[0][0] * data2[0][0]]]", {5}, {3})
```

See what we mean?  But for anything involving arrays, `PY.ARR` is the way to go.  Here's a simple example that takes a row array and returns a single cell:

```excel
=BOARDFLARE.PY.ARR("total = sum(data1[0]); pyout = [[total]]", {1,2})
```
This sets global `data1 = [[1,2]]`, so `pyout = [[3]]`, which outputs `3` in a single cell in Excel.

Or using numpy and returning a row:

```excel
=BOARDFLARE.PY.ARR("import numpy as np; total = np.sum(data1[0]).item(); pyout = [['Sales', total]]", {1,2})
```
This sets global `data1 = [[1,2]]`, so `pyout = [['Sales', 3]]`, which outputs a row with `Sales` in one cell and `3` in the next cell.

You can also load code from URL:

```excel
=BOARDFLARE.PY.ARR("https://foo.com/code.py", {1,2})
```
### PY.BETA

`PY.BETA` has been updated to handle scalars the same as `PY` and arrays the same as `PY.ARR`.  It fundamentally operates on arrays so it can do both, but it has helpers to convert scalars to arrays and arrays to scalars so this is less tedious when handling scalars.  The plan is this code will replace the current `PY` function, and `PY.ARR` will be deprecated.

On the input side, the conversion rules are outlined in the table below:

| Input Type       | Conversion Rule             | Raw Input            | Global                |
|------------------|-----------------------------|----------------------|-----------------------|
| Cell             | Converted to a scalar       | `[[5]]`              | `5`                   |
| Column           | Flattened to a simple array | `[[1], [2]]`         | `[1, 2]`              |
| Row              | Flattened to a simple array | `[[1, 2]]`           | `[1, 2]`              |
| Matrix (m x n)   | Untouched                   | `[[1, 2], [3, 4]]`   | `[[1, 2], [3, 4]]`    |

So if you select a single cell for `data1`, instead of having to access the scalar with `data1[0][0]`, it will be converted to a scalar for you.  Similarly, if you select a column or a row, it will be flattened to a simple array.  If you need to know whether a simple array came from a column or row, you can access the raw input on the `data` global variable, which is an array of elements representing `data1`, `data2`, etc.

On the output side, it is the opposite, as follows:

| Output Type | Conversion Rule            | pyout               | Array Value to Excel       |
|-------------|-----------------------------|---------------------|----------------------------|
| Scalar      | Converted to an array cell  | `5`                 | `[[5]]`                    |
| Array       | Converted to a row          | `[1, 2]`            | `[[1, 2]]`                 |
| Matrix      | Untouched                   | `[[1, 2], [3, 4]]`  | `[[1, 2], [3, 4]]`         |

So the clumsy example given earlier of trying to multiply two scalars:

```excel
=BOARDFLARE.PY.ARR("pyout = [[data1[0][0] * data2[0][0]]]", {5}, {3})
```

Could be written as:

```excel
=BOARDFLARE.PY.BETA("pyout = data1 * data2", 5, 3)
```

Or you could do the following, which shows how `data1`, `data2` row matrices have been flattened to simple arrays, and the resulting python list has been converted to a row matrix Excel is expecting, keeping your Python code simpler to write:

```excel
=BOARDFLARE.PY.BETA("pyout = [a * b for a, b in zip(data1, data2)]", {5,3}, {3,4})
={15, 12}
```

So the best of both worlds in one function.

## Development

### Code from URL

Code can only be loaded from a URL if it is served over HTTPS due to browser security restrictions.  Deploying your code to a URL such as a [GitHub Gist](https://gist.github.com/) has the benefit of being able to update your function without having to update all the Excel workbooks using it, as well as providing better version control.  If you use a GitHub Gist, make sure you click on the raw button in the Gist to get a URL that goes directly to your code [like this](https://gist.githubusercontent.com/bolleman/14e68b8d6a6e2897ef5f70dbd28ea7e3/raw/ce32551dd5df578371d70db563459d450921f13b/emails.py).

### Local IDE

Using an IDE such as [VS Code](https://code.visualstudio.com/) with something like [Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) enables you to work with your local code files with live reload as follows: 

```excel
=BOARDFLARE.PY.ARR("https://localhost:4000/mycode.py", {1,2})
```

### JupyterLite

[Jupyterlite](https://jupyterlite.readthedocs.io/en/stable/_static/lab/index.html) runs in the browser using the same Pyodide Python kernal that this add-in is using, so any code that runs in Jupyterlite should run in Python for Excel.  Once you have your code running in Jupyterlite, you can move it into Excel by copy/paste, or one of the following methods:
- sync notebook to a GitHub Gist
- load notebook code using the `BOARDFLARE.JL` function
- use AI to help write code.

** Details Coming Soon **

## Applications

Some example applications are as follows:

1. **Data extraction**: Python has several libraries available for extracting data from strings.  For example, if you load HTML using PowerQuery, you could parse it using [BeautifulSoup](https://pypi.org/project/beautifulsoup4/).

2. **Data manipulation**: [pandas](https://pandas.pydata.org/) is a popular library for manipulating tabular data and might be a good alternative to PowerQuery for some tasks.

3. **Using AI models**: AI models can be called via APIs with complex prompts and agentic patterns using packages like [LangChain](https://pypi.org/project/langchain/).

4. **Calling APIs**:  For example, let's say you're trying to call a REST API and manipulate the JSON response into something useful.

## Changelog

1.0.5 - 2024-10-09
- `PY.BETA` handles both arrays and scalars with auto-conversion helpers.
- Beta version of Jupyterlite with `BOARDFLARE.JL` function.

1.0.4 - 2024-09-25
- Added ability to load code from URL to `PY` and `PY.ARR` functions.  `PY.BETA` now has no new features, but will be where new features are tested before moving to `PY` and `PY.ARR`.

1.0.3 - 2024-09-24
- Added `PY.BETA` function with ability to load code from a URL.
- Improved error handling.
- Fixed bug blocking Mac users.

1.0.2 - 2024-09-15
- Improved error handling and reporting.
- Changed to using `pyout` as the output variable.

1.0.1 - 2024-09-12
- Added `PY.ARR` function to handle arrays natively.

1.0.0 - 2024-09-10
- Initial release.  